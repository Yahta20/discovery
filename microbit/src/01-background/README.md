# База

## Що таке мікроконтроллер?

Мікроконтроллер це *система* у чипі. Навідміну від комьютера зібраного з дискретних компонентів:
процессор, оперативна та накопичувальна пам'ять, порт Ethernet, тощо; в мікроконтроллері все це
вбудовано в одному чипіЦе дає можливість будувати системи з меньшою кількістью частин.

## Що ти можешь зробити з мікроконтроллером?


До біса чтого! Мікроконтроллер центральна фігура у оповіданні яке ми називаемо "*вбудовані* системи".
Вбудовані системи скрізь, але ти зазвичай не звертаєш на них увагу. Вони контролюють машини що
перуть твій одяг, друкують твої документи, готують твою їжу. В будівлях яких ти працюєш та живеш 
вони підтримують сприятливу температуру, та конролють компоненти що творять рушійну силу у транспортному
зобі яким ви подорожуєте.

Більшість вбудованих систем працюють без втручання користувача. Навіть якщо є інтерфейс користувача 
як в пральних машин; більшість їх роботи вони роблять самотужки.

Вбудовані системи часто використовуються для *контролю* фізичного процесу. 
Щоб зробити це можливим, вони мають один або кілька пристроїв, 
які повідомляють їм про стан світу («сенсори»), і один або кілька пристроїв, 
які дозволяють їм змінювати речі («приводи»). Наприклад, може бути система клімат-контролю будівлі:

- Датчики, які вимірюють температуру та вологість у різних місцях.
- Приводи, що регулюють швидкість вентиляторів.
- Приводи, які викликають додавання або видалення тепла з будівлі.

## Коли слід використовувати мікроконтролер?

Багато вбудованих систем, перерахованих вище, можна реалізувати на комп’ютері під керуванням Linux 
(наприклад наприклад "Raspberry Pi"). Навіщо замість цього використовувати мікроконтролер? 
Здається, це може бути важче розробити програму.

Деякі причини можуть включати:

**Ціна.** Мікроконтролер набагато дешевший, ніж комп'ютер загального призначення. 
Мало того, що мікроконтролер дешевший; для роботи також потрібно набагато менше зовнішніх електричних компонентів. 
Це робить друковані плати (PCB) меншими та дешевшими у розробці та виробництві.

**Споживання енергії.** Більшість мікроконтролерів споживають лише частку потужності, 
ніж повномасштабні процесор. Для програм, які працюють від батарейок, це має величезне значення.

**Чуйність.** Щоб досягти своєї мети, деякі вбудовані системи повинні завжди реагувати протягом 
обмеженого інтервалу часу (наприклад, «антиблокувальна» гальмівна система автомобіля). 
Якщо система пропустить цей тип *дедлайну*, може статися катастрофічний збій. 
Такий кінцевий термін називається вимогою «жорсткого реального часу». Вбудована система, яка обмежена таким терміном,
називається "системою жорсткого реального часу". Комп’ютер загального призначення та ОС зазвичай мають 
багато програмних компонентів, які спільно використовують ресурси обробки комп’ютера. 
Через це важче гарантувати виконання програми в жорсткі часові обмеження.

**Надійність.** У системах з меншою кількістю компонентів (як апаратного, так і програмного забезпечення) залишається менше неправильно!

## Коли мені *не* використовувати мікроконтролер?

Там, де задіяні важкі обчислення. Для підтримки низького енергоспоживання мікроконтролери 
мають дуже обмежені обчислювальні ресурси. Наприклад, деякі мікроконтролери навіть 
не мають апаратної підтримки для операцій з плаваючою комою. На цих пристроях виконання 
простого додавання чисел одинарної точності може зайняти сотні циклів ЦП.

## Навіщо використовувати Rust, а не C?

Сподіваюся, мені не потрібно переконувати вас тут, оскільки ви, мабуть, знайомі з 
мовними відмінностями між Rust і C. Один момент, який я хочу підняти, це керування пакетами. 
C не має офіційного, широко прийнятого рішення для керування пакунками, тоді як у Rust є Cargo. 
Це *набагато* полегшує розвиток. І, IMO, просте керування пакетами заохочує повторне використання коду, 
оскільки бібліотеки можна легко інтегрувати в програму, що також добре, оскільки 
бібліотеки отримують більше «бойового тестування».

## Чому б мені не використовувати Rust?

Або чому я маю віддати перевагу C, а не Rust?

Екосистема C набагато зріліша. Готові рішення для кількох проблем уже існують. Якщо
вам потрібно контролювати чутливий до часу процес, ви можете взяти один із існуючих комерційних Real Time
Operating Systems (RTOS) це вирішить вашу проблему. У Rust ще немає комерційних RTOS виробничого класу, тож вам доведеться або створити їх самостійно, або спробувати одну з тих, що перебувають у розробці. Ви можете знайти їх список у репозиторії [Awesome Embedded Rust].

[Awesome Embedded Rust]: https://github.com/rust-embedded/awesome-embedded-rust#real-time-operating-system-rtos
